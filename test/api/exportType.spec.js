/* global expect */
describe('exportType', () => {
  let parentExpect;
  let childExpect;
  beforeEach(() => {
    parentExpect = expect.clone();
    childExpect = parentExpect.child();
  });

  it('is chainable', () => {
    childExpect
      .exportType({ name: 'abc', identify: false })
      .exportType({ name: 'def', identify: false });

    expect(parentExpect.getType('abc')).toSatisfy({ name: 'abc' });
    expect(parentExpect.getType('def')).toSatisfy({ name: 'def' });
  });

  it('makes the type available to the parent expect', () => {
    childExpect.exportType({
      name: 'fooString',
      identify(obj) {
        return typeof obj === 'string' && /^foo/.test(obj);
      },
    });

    parentExpect.addAssertion('<fooString> to foo', function (expect, subject) {
      expect(subject).toEqual('foo');
    });
  });

  it('does not make the type available to a parent parent expect', () => {
    childExpect.child().exportType({
      name: 'abc',
      identify(obj) {
        return obj === 'abc';
      },
    });
    expect(parentExpect.findTypeOf('abc')).toSatisfy({ name: 'string' });
  });

  it('binds the type to the child expect so custom types are available to the inspect function', () => {
    childExpect.addStyle('fancyQuotes', function (text) {
      this.text('>>').text(text).text('<<');
    });

    childExpect.exportType({
      name: 'yadda',
      identify(obj) {
        return /^yadda/.test(obj);
      },
      inspect(value, depth, output, inspect) {
        return output.fancyQuotes(value);
      },
    });
    expect(
      parentExpect.createOutput('text').appendInspected('yaddablah').toString()
    ).toEqual('>>yaddablah<<');
  });

  it('binds the type to the child expect so custom types are available to the diff function', () => {
    childExpect.addStyle('fancyQuotes', function (text) {
      this.text('>>').text(text).text('<<');
    });

    childExpect.exportType({
      name: 'yadda',
      identify(obj) {
        return /^yadda/.test(obj);
      },
      inspect(value, depth, output, inspect) {
        return output.fancyQuotes(value);
      },
      diff(actual, expected, output) {
        output
          .text('got ')
          .fancyQuotes(actual)
          .text(' but expected ')
          .fancyQuotes(expected);
      },
    });
    expect(
      parentExpect
        .getType('yadda')
        .diff(
          'yaddafoo',
          'yaddabar',
          parentExpect.createOutput('text').text('hey, ')
        )
        .toString()
    ).toEqual('hey, got >>yaddafoo<< but expected >>yaddabar<<');
  });

  it('should correctly append output generated by a inspect function that does not return the output', () => {
    childExpect.addStyle('fancyQuotes', function (text) {
      this.text('>>').text(text).text('<<');
    });

    childExpect.exportType({
      name: 'yadda',
      identify(obj) {
        return /^yadda/.test(obj);
      },
      inspect(value, depth, output, inspect) {
        output.fancyQuotes(value);
        if (value.length > 5) {
          output.append(value.substr(0, value.length - 1));
          output.appendInspected(value.substr(0, value.length - 1));
        }
      },
    });
    expect(
      parentExpect.createOutput().appendInspected('yaddafoo').toString()
    ).toEqual('>>yaddafoo<<yaddafo>>yaddafo<<yaddaf>>yaddaf<<yadda>>yadda<<');
  });

  // Weird regression test, used throw TypeError: Cannot read property 'subject' of undefined
  it('should not break when inspecting the exported type in a diff', () => {
    childExpect.exportType({
      name: 'abc',
      identify(obj) {
        return obj === 'abc';
      },
    });
    expect(function () {
      expect(parentExpect.findTypeOf('abc')).toSatisfy({
        name: 'string',
      });
    }).toThrow(/^expected/);
  });
});
